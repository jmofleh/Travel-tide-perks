# -*- coding: utf-8 -*-
"""data_preprocessing_and_eda.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PUj0he3a1p4NpSB9dWiJNdBYztwkCw1i
"""

# import pandas
import pandas as pd

#Connect with google drive
from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

# Connect with directory and data file, read number of columns and record
directory = "/content/drive/MyDrive/Travel tide project"

df_session_base = pd.read_csv(directory + "/travel_tide.csv")
#df_session_base = pd.read_csv(directory + "/not_canceled_trips.csv")


print(df_session_base.shape)
display(df_session_base.head())

"""In the next cell two data frames will be created, data types will be standardized  and several  coulumns will be converted  from text into proper datetime format in both DataFrames so that time-based calculations and analysis can be performed correctly

"""

# two data frames: data type standardization and date conversion
df_trips = df_session_base.convert_dtypes()
df_session_base = df_session_base.convert_dtypes()

cols = ['session_start', 'session_end', 'birthdate', 'sign_up_date', 'departure_time', 'return_time', 'check_in_time', 'check_out_time']

for c in cols:
  df_trips[c] = pd.to_datetime(df_trips[c], format='mixed')
  df_session_base[c] = pd.to_datetime(df_session_base[c], format='mixed')

"""I converted selected timestamp columns into proper datetime format and then calculated the length of each session in seconds by subtracting start time from end time."""

datetime_cols = ['session_start', 'session_end', 'departure_time', 'return_time']

for col in datetime_cols:
    df_session_base[col] = pd.to_datetime(df_session_base[col], format='mixed')

df_session_base['session_duration'] = (df_session_base['session_end'] - df_session_base['session_start']).dt.total_seconds()
display(df_session_base[['session_start', 'session_end', 'session_duration']].head(1))

"""# To read number of null in different columns"""

df_session_base.isnull().sum()

"""# Show the summary statisstics of df session (transposed)"""

# Show the summary statisstics of df session (transposed)
df_session_base.describe().T.round(2)

"""I filtered the dataset to find trips with zero or negative nights, selected relevant columns, and displayed two sample rows for inspection."""

df_session_base[df_session_base['nights'] <= 0][['trip_id', 'check_in_time', 'check_out_time', 'nights']].head(2)

"""# Convert 'birthdate' to datetime objects  (Request of learning Journey)"""

# Convert 'birthdate' to datetime objects  (Request of learning Journey)
df_session_base['birthdate'] = pd.to_datetime(df_session_base['birthdate'])

# Display the earliest and latest birthdates
print(f"Earliest birthdate: {df_session_base['birthdate'].min()}")
print(f"Latest birthdate: {df_session_base['birthdate'].max()}")

# Extract birth year( Request of learning Journey)
df_session_base['birth_year'] = df_session_base['birthdate'].dt.year

# Get the current year to calculate age
current_year = pd.to_datetime('today').year

# Calculate age
df_session_base['age'] = current_year - df_session_base['birth_year']

# Display summary statistics for age
print("Summary statistics for Age:" )
display((df_session_base['age'].describe().round(1).to_frame()
    .T))

# Display the distribution of birth years(Request of learning Journey))
print("Top 10 most common birth years:")
display(df_session_base['birth_year'].value_counts().head(10))

"""I filtered the dataset to show sessions with at least 100 page clicks and displayed key columns to analyze high-engagement user behavior."""

# high engagement behaviour(?)
df_session_base[df_session_base['page_clicks'] >= 100][['user_id', 'trip_id', 'hotel_booked', 'flight_booked', 'session_duration', 'page_clicks']]

"""# New column Marriage status based on the 'married' column (EDA)"""

# New column Marriage status based on the 'married' column (EDA)
df_session_base['marriage_status'] = df_session_base['married'].map({True: 'Married', False: 'Not Married'})

print("Marriage Status Distribution:")
display(df_session_base['marriage_status'].value_counts())

"""# EDA graphs"""

#EDA graphs
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df = df_session_base.copy()

light_blue = "#ADD8E6"   # Light blue color

sns.set_style("whitegrid")
plt.style.use("ggplot")

print("\n--- Generating Visualizations for df_session ---")

# --- Figure 1: Distribution plots ---
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(14, 10))
fig.suptitle('Distribution of Session Metrics', fontsize=16)

sns.histplot(df['page_clicks'], bins=20, kde=True, color="#5DADE2", ax=axes[0, 0])
axes[0, 0].set_title('Distribution of Page Clicks')

sns.histplot(df['nights'], bins=10, kde=False, color=light_blue, ax=axes[0, 1])
axes[0, 1].set_title('Distribution of Nights Booked')

sns.histplot(df['base_fare_usd'], bins=20, kde=True, color= light_blue, ax=axes[1, 0])
axes[1, 0].set_title('Distribution of Base Fare (USD)')

sns.histplot(df['hotel_price_per_room_night_usd'], bins=20, kde=True, color="#AF7AC5", ax=axes[1, 1])
axes[1, 1].set_title('Distribution of Hotel Price per Room Night (USD)')

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()


# --- Figure 2: Categorical count plots ---
fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 6))
fig.suptitle('Booking and Discount Statuses', fontsize=16)

booked_df = df[['flight_booked', 'hotel_booked']].melt(
    var_name='Booking Type', value_name='Booked')
sns.countplot(x='Booking Type', hue='Booked', data=booked_df, ax=axes[0], palette="Blues")
axes[0].set_title('Flight vs. Hotel Booked')
axes[0].set_xlabel('Booking Type')
axes[0].set_ylabel('Count')

# Count plot for flight and hotel discounts
discount_df = df[['flight_discount', 'hotel_discount']].melt(var_name='Discount Type', value_name='Applied')
sns.countplot(x='Discount Type', hue='Applied', data=discount_df,palette="Blues", ax=axes[1])
axes[1].set_title('Flight vs. Hotel Discount Applied')
axes[1].set_xlabel('Discount Type')
axes[1].set_ylabel('Count')

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

# Figure 3: Relationship plots
fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 6))
fig.suptitle('Relationships in Session Data', fontsize=16)

# Scatter plot: Page clicks vs. Base fare
sns.scatterplot(x='page_clicks', y='base_fare_usd', data=df, ax=axes[0])
axes[0].set_title('Page Clicks vs. Base Fare (USD)')
axes[0].set_xlabel('Page Clicks')
axes[0].set_ylabel('Base Fare (USD)')

# Box plot: Base fare by flight booked
sns.boxplot(
    x='flight_booked',
    y='base_fare_usd',
    hue='flight_booked',
    data=df,
    palette="Blues",
    ax=axes[1],
    showfliers=False,
    legend=False
)

axes[1].set_title('Base Fare by Flight Booked (Outliers Removed)')
axes[1].set_xlabel('Flight Booked')
axes[1].set_ylabel('Base Fare (USD)')

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

"""# Histogram session duration"""

# Historgraph/plot session duration
def plot_distribution(df, column_name):

  import matplotlib.pyplot as plt
  import seaborn as sns
  fig, axes = plt.subplots(1, 2, figsize=(12, 6))

  # Boxplot
  sns.boxplot(y=df[column_name], ax=axes[0])
  axes[0].set_title(f'Boxplot of {column_name}')

  # Histogram
  sns.histplot(df[column_name], ax=axes[1], kde=True)
  axes[1].set_title(f'Histogram of {column_name}')

  plt.tight_layout()
  plt.show()
  import matplotlib.pyplot as plt
plot_distribution(df_session_base, 'session_duration')

"""#Flight destination by volumn(number of flights per destination -map)"""

#Flight destination by volumn(map)

df = df[["destination_airport_lon", "destination_airport_lat", 'destination']].copy()
df.dropna(inplace=True)

print(df.shape)

import plotly.express as px
import pandas as pd

#  Aggregate the data: Count flights per destination

map_df = df.groupby(['destination', 'destination_airport_lat', 'destination_airport_lon']).size().reset_index(name='flight_count')


fig = px.scatter_geo(
    map_df,
    lat='destination_airport_lat',
    lon='destination_airport_lon',
    size='flight_count',
    hover_name='destination',
    projection="natural earth",
    title='Flight Destinations by Volume',
    template='plotly_white'
)

fig.update_traces(marker=dict(color='Green', line=dict(width=2, color='Blue')))


fig.show()

"""Handling outliers in two methods, removing the outliers and clipping of outliers"""

#Removes outliers from a specified column in a DataFrame using the IQR method, prepared for general use.
def remove_outliers_iqr(df, column_name):

  Q1 = df[column_name].quantile(0.25)
  Q3 = df[column_name].quantile(0.75)
  IQR = Q3 - Q1

  lower_bound = Q1 - 5 * IQR
  upper_bound = Q3 + 5 * IQR

  original_rows = df.shape[0]
  df_cleaned = df[(df[column_name] >= lower_bound) & (df[column_name] <= upper_bound)].copy()
  removed_rows = original_rows - df_cleaned.shape[0]

  print(f"Removed {removed_rows} outliers from the '{column_name}' column.")

  return df_cleaned

# Outlier removed from session duration and graph
df_cleaned = remove_outliers_iqr(df_session_base, 'session_duration')
plot_distribution(df_cleaned, 'session_duration')

#clip outliers
def clip_outliers_iqr(df, column_name):
  Q1 = df[column_name].quantile(0.25)
  Q3 = df[column_name].quantile(0.75)
  IQR = Q3 - Q1

  # Using 5 * IQR for consistency with the remove_outliers_iqr function
  lower_bound = Q1 - 5 * IQR
  upper_bound = Q3 + 5 * IQR

  df_clipped = df.copy()
  df_clipped[column_name] = df_clipped[column_name].clip(lower=lower_bound, upper=upper_bound)

  print(f"Clipped outliers in the '{column_name}' column using IQR method.")
  return df_clipped

df_session_clip = clip_outliers_iqr(df_session_base, "page_clicks")
df_session_clip = clip_outliers_iqr(df_session_clip, "session_duration")
#remove outliers
df_session_rm = remove_outliers_iqr(df_session_base, "page_clicks")
df_session_rm = remove_outliers_iqr(df_session_rm, "session_duration")

plot_distribution(df_session_clip, 'page_clicks')
plot_distribution(df_session_base, "nights")

"""#Number of nights (Hotel) -2 and-1 nights changed to Zero"""

#Number of nights (Hotel)
import pandas as pd

nights_distribution = (
    df_session_base.groupby("nights")
          .size()
          .reset_index(name="rows")
          .sort_values("nights")
)
df_session_base.loc[df_session_base["nights"] < 0, "nights"] = 0 #-2 and -1 nights changed to zero.
print(nights_distribution)

"""#  if trip includes a flight, a hotel, both, or neither, and counts how many trips fall into each category."""

# How many trips had flights and hotels or any of them
trip_summary = df_session_base.groupby("trip_id").agg(
    has_flight=("departure_time", lambda x: x.notna().any()),
    has_hotel=("hotel_name", lambda x: x.notna().any())
).reset_index()

print(trip_summary[["has_flight", "has_hotel"]].value_counts())

#I filtered trip rows, cleaned numeric data, calculated per-row spending,
# and aggregated everything into a clean trip-level dataset with total costs per trip.

df_trip = df_session_base[df_session_base["trip_id"].notna()].copy()

# Convert numeric columns safely
num_cols = ["seats", "base_fare_usd", "nights", "rooms", "hotel_price_per_room_night_usd"]
for c in num_cols:
    df_trip[c] = pd.to_numeric(df_trip[c], errors="coerce").fillna(0)

# Clean invalid nights
df_trip.loc[df_trip["nights"] <= 0, "nights"] = 0

# Spend per row
df_trip["flight_spend_row"] = df_trip["seats"] * df_trip["base_fare_usd"]
df_trip["hotel_spend_row"] = (
    df_trip["nights"] * df_trip["rooms"] * df_trip["hotel_price_per_room_night_usd"]
)
df_trip["total_spend_row"] = df_trip["flight_spend_row"] + df_trip["hotel_spend_row"]

# Aggregate to trip-level
trip_table = (
    df_trip.groupby("trip_id", as_index=False)
    .agg(
        user_id=("user_id", "first"),
        destination=("destination", "first"),
        trip_airline=("trip_airline", "first"),
        origin_airport=("origin_airport", "first"),
        destination_airport=("destination_airport", "first"),
        departure_time=("departure_time", "first"),
        return_time=("return_time", "first"),

        hotel_name=("hotel_name", "first"),
        total_nights=("nights", "sum"),
        total_rooms=("rooms", "sum"),

        flight_spend=("flight_spend_row", "sum"),
        hotel_spend=("hotel_spend_row", "sum"),
        total_spend=("total_spend_row", "sum")
    )
)

trip_table.head(2)

"""#Aggreates of nights, rooms, flight and hotel spending at user ID level"""

#Aggreates of nights, rooms, flight and hotel spending at user ID level
user_table = (
    trip_table
    .groupby("user_id", as_index=False)
    .agg(
        total_nights=("total_nights", "sum"),
        total_rooms=("total_rooms", "sum"),
        total_flight_spend=("flight_spend", "sum"),
        total_hotel_spend=("hotel_spend", "sum"),
        total_spend=("total_spend", "sum")
    )
)

user_table.head()

"""# Finding canceled and not canceled trips"""

#find canceled sessions from SQL database
import pandas as pd
from sqlalchemy import create_engine

# Define your PostgreSQL connection parameters
username = 'USERNAME'
password = 'PASSWORD'
host = 'ep-noisy-flower-846766.us-east-2.aws.neon.tech'        # or your DB host
port = '5432'             # default PostgreSQL port
database = 'TravelTide'

# Create connection string using SQLAlchemy
conn_str = f'postgresql+psycopg2://{username}:{password}@{host}:{port}/{database}'
engine = create_engine(conn_str)

query = '''
SELECT DISTINCT trip_id
FROM sessions
WHERE cancellation = TRUE
'''

canceled_trip_ids = set(pd.read_sql(query, engine)['trip_id'].values)
print('Number of canceled trips (total)', len(canceled_trip_ids))
engine.dispose()

# counts rows per cancellation status
df_session_base.groupby("cancellation").size().reset_index(name="count")

# Breakdown of Cancelled Trips by Booking Type
cancelled_trips_df = df_session_base[df_session_base['cancellation'] == True]

# Get unique cancelled trip IDs
unique_cancelled_trip_ids = cancelled_trips_df['trip_id'].unique()

# Define trip_summary
trip_summary = df_trip.groupby("trip_id").agg(
    has_flight=("departure_time", lambda x: x.notna().any()),
    has_hotel=("hotel_name", lambda x: x.notna().any())
).reset_index()

# Filter trip_summary to get details for only cancelled trips
cancelled_trip_details = trip_summary[trip_summary['trip_id'].isin(unique_cancelled_trip_ids)]


# Count the occurrences of each combination
cancellation_type_counts = cancelled_trip_details[['has_flight', 'has_hotel']].value_counts().reset_index(name='count')
cancellation_type_counts['booking_type'] = cancellation_type_counts.apply(
    lambda row: 'Flight and Hotel' if row['has_flight'] and row['has_hotel']
    else ('Flight Only' if row['has_flight']
    else ('Hotel Only' if row['has_hotel']
    else 'Unknown/Other')),
    axis=1
)

print("Breakdown of Cancelled Trips by Booking Type:")
display(cancellation_type_counts[['booking_type', 'count']])

#Only non-canceled trips and printed how many rows (sessions) those trips have.
df_temp = df_session_base.dropna(subset = ['trip_id'])
df_not_canceled_trips = df_temp[~df_temp['trip_id'].isin(canceled_trip_ids)]
print(df_not_canceled_trips.shape[0])

# check number of null in df
print(df_not_canceled_trips.isnull().sum())

"""#I cleaned trip IDs, counted sessions, trips, and canceled trips per user,and merged everything into a single user-level summary table"""

#I cleaned trip IDs, counted sessions, trips, and canceled trips per user,
# and merged everything into a single user-level summary table.

# Ensure column cleanliness if needed
df_session_base["trip_id"] = df_session_base["trip_id"].astype(str).str.strip()
df_session_base["trip_id"] = df_session_base["trip_id"].replace(["", "nan", "None", "null"], pd.NA)

# 1) Number of sessions per user
sessions_per_user = df_session_base.groupby("user_id")["session_id"].nunique().reset_index(name="num_sessions")

# 2) Number of trips per user (trip_id not null)
trips_per_user = (
    df_session_base[df_session_base["trip_id"].notna()]
    .groupby("user_id")["trip_id"]
    .nunique()
    .reset_index(name="num_trips")
)

# 3) Count canceled trips per user using the 'cancellation' column
# Filter for actual canceled entries where trip_id is also present
canceled_df = df_session_base[(df_session_base['cancellation'] == True) & (df_session_base['trip_id'].notna())]

canceled_trips_per_user = (
    canceled_df.groupby("user_id")["trip_id"]
    .nunique()
    .reset_index(name="num_canceled_trips")
)

# 4) Merge into one final table
user_summary = (
    sessions_per_user
    .merge(trips_per_user, on="user_id", how="left")
    .merge(canceled_trips_per_user, on="user_id", how="left")
)

# Fill missing (users with 0 trips or 0 canceled trips)
user_summary["num_trips"] = user_summary["num_trips"].fillna(0).astype(int)
user_summary["num_canceled_trips"] = user_summary["num_canceled_trips"].fillna(0).astype(int)

user_summary.head()



"""# I built user-level features counting how many trips each user canceled and how many trips they had in total."""

df_user_base1 = canceled_df.groupby('user_id').agg(
 num_canceled_trips = ('trip_id', 'nunique')
).reset_index()

df_user_base2 = df_session_base[df_session_base['trip_id'].notna()].groupby('user_id').agg(
 num_trips = ('trip_id', 'nunique')
).reset_index()

df_user_base1= pd.merge(df_user_base1, df_user_base2, on='user_id', how='left')
df_user_base1.head()

"""### Comparing Number of Trips to Cancelled Trips

To understand the relationship between the total number of trips and cancelled trips, we can calculate a cancellation rate per user. This metric will show what percentage of a user's trips ended up being cancelled.
"""

# Calculate cancellation rate, handling division by zero
user_summary['cancellation_rate'] = user_summary.apply(
    lambda row: (row['num_canceled_trips'] / row['num_trips']) if row['num_trips'] > 0 else 0,
    axis=1
)


print("Descriptive statistics for cancellation rate:")
display(user_summary['cancellation_rate'].describe().round(3)),

print("\nTop 10 users by cancellation rate (excluding users with 0 trips initially, if desired):")
display(user_summary[user_summary['num_trips'] > 0].sort_values(by='cancellation_rate', ascending=False).head(10))


plt.show()



"""I counted the number of flights per booking and calculated the actual money spent per flight and hotel after applying any discounts. I also calculated the advance booking time in days by measuring the difference between booking completion and travel departure."""

# count number of Flights
import numpy as np
import pandas as pd

# Ensure boolean columns are treated as standard booleans (NA becomes False) for logical operations
flight_booked_bool = df_session_base['flight_booked'].fillna(False).astype(bool)
return_flight_booked_bool = df_session_base['return_flight_booked'].fillna(False).astype(bool)
flight_discount_bool = df_session_base['flight_discount'].fillna(False).astype(bool)
hotel_discount_bool = df_session_base['hotel_discount'].fillna(False).astype(bool)

# count number of Flights
df_session_base['num_flights'] = np.where(
    #if
    (flight_booked_bool == True) & (return_flight_booked_bool == True),
    2,
    #else
    np.where(
        (flight_booked_bool == True) & (return_flight_booked_bool == False),
        1,0
    )
)

df_session_base['money_spent_per_flight'] = np.where(
    (flight_discount_bool == True),
    df_session_base['base_fare_usd'] * (1 - df_session_base['flight_discount_amount']),
    df_session_base['base_fare_usd']
)

df_session_base['money_spent_per_seat'] = df_session_base['money_spent_per_flight'] / df_session_base['seats']

# money spent per hotel (total)
# rooms * nights * price_per_room_per_night
df_session_base['money_spent_total_hotel'] = df_session_base['rooms'] * df_session_base['nights'] * df_session_base['hotel_price_per_room_night_usd']

df_session_base['money_spent_per_hotel'] = np.where(
    (hotel_discount_bool == True),
    df_session_base['money_spent_total_hotel'] * (1 - df_session_base['hotel_discount_amount']),
    df_session_base['money_spent_total_hotel']
)

# Convert necessary columns to datetime
df_session_base['departure_time'] = pd.to_datetime(df_session_base['departure_time'], errors='coerce')
df_session_base['check_in_time'] = pd.to_datetime(df_session_base['check_in_time'], errors='coerce')
df_session_base['session_end'] = pd.to_datetime(df_session_base['session_end'], errors='coerce') # Added this line

# Time after booking
df_session_base['time_after_booking'] = np.where(
    (flight_booked_bool == True),
    (df_session_base['departure_time'] - df_session_base['session_end']).dt.days,
    (df_session_base['check_in_time'] - df_session_base['session_end']).dt.days
)
display(df_session_base[[
    'user_id',
    'flight_booked',
    'return_flight_booked',
    'num_flights',
    'money_spent_per_flight',
    'money_spent_per_seat',
    'money_spent_per_hotel',
    'time_after_booking'
]].head())

display(df.head(2))

df.to_csv(f'{directory}/session_base.csv', index=False)

# file downloaded
from google.colab import files

# Define the full path to the file
file_path = f'{directory}//session_base.csv'

# Download the file
files.download(file_path)